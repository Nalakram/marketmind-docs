import abc
from .columns import op_chain as op_chain
from .cuda_runtime import capabilities as capabilities
from .errors import SchemaMismatch as SchemaMismatch, UnsupportedAST as UnsupportedAST
from _typeshed import Incomplete
from abc import ABC, abstractmethod
from typing import Any, Callable

logger: Incomplete

class Transform(ABC, metaclass=abc.ABCMeta):
    backend: Incomplete
    def __init__(self, fn: Callable[[Any], Any], backend: str | None = None) -> None: ...
    def __call__(self, df): ...
    def apply(self, df): ...
    def __add__(self, other: Transform) -> Transform: ...
    @abstractmethod
    def validate(self, df) -> None: ...

class CompositeTransform(Transform):
    def __init__(self, fn: Callable[[Any], Any], backend: str | None = None) -> None: ...
    def validate(self, df) -> None: ...

def profile_transform(func: Callable) -> Callable: ...

class NormalizeTransform(Transform):
    def __init__(self, col: str, mean: float | None = None, std: float | None = None) -> None: ...
    @profile_transform
    def apply(self, df): ...
    def validate(self, df) -> None: ...

class BollingerTransform(Transform):
    output_cols: Incomplete
    def __init__(self, col: str, window: int = 20, num_std: float = 2.0, output_cols: list[str] | None = None) -> None: ...
    @profile_transform
    def apply(self, df): ...
    def validate(self, df) -> None: ...

class LogTransform(Transform):
    def __init__(self, col: str, base: float = 10.0, eps: float = 1e-12) -> None: ...
    @profile_transform
    def apply(self, df): ...
    def validate(self, df) -> None: ...

class MinMaxScaleTransform(Transform):
    def __init__(self, col: str, min_val: float | None = None, max_val: float | None = None, eps: float = 1e-12) -> None: ...
    @profile_transform
    def apply(self, df): ...
    def validate(self, df) -> None: ...

class ToTorchTransform(Transform):
    def __init__(self, cols: list[str], dtypes: dict[str, Any] | None = None, include_lengths: bool = False) -> None: ...
    def validate(self, df) -> None: ...

class TransformFactory:
    @classmethod
    def register(cls, name: str, builder: Callable[..., Transform]): ...
    @classmethod
    def build(cls, name: str, **kwargs) -> Transform: ...
    @classmethod
    def compose(cls, *names: str, **kwargs) -> Transform: ...
    @classmethod
    def auto_register_from_exprs(cls): ...

def feature_engineer_chain(cols: list[str]) -> Transform: ...
