import abc
from .errors import UnsupportedAST as UnsupportedAST
from typing import Any as Incomplete
from abc import ABC, abstractmethod
from dataclasses import dataclass
from srcPy.ops.mm_logkit import get_logger as get_logger
from typing import Any, Callable, Hashable

logger: Incomplete

@dataclass(frozen=True)
class Spec(ABC, Hashable, metaclass=abc.ABCMeta):
    """spec class."""
    def __post_init__(self) -> None: ...
    def __hash__(self) -> int: ...
    @abstractmethod
    def to_backend_spec(self, backend: str) -> Any: ...
    def validate(self) -> None: ...

@dataclass(frozen=True)
class WindowSpec(Spec):
    """window spec class."""
    partition_by: list[str] | None = ...
    order_by: list[str] | None = ...
    preceding: int | None = ...
    following: int | None = ...
    min_periods: int = ...
    def validate(self) -> None: ...
    def to_backend_spec(self, backend: str) -> Any: ...
    def __add__(self, other: WindowSpec) -> WindowSpec: ...

@dataclass(frozen=True)
class GroupSpec(Spec, metaclass=abc.ABCMeta):
    """group spec class."""
    by: list[str]
    as_index: bool = ...
    sort: bool = ...
    def validate(self) -> None: ...
    def __add__(self, other: GroupSpec) -> GroupSpec: ...

class SpecFactory:
    """Factory for creating spec instances."""
    registry: dict[str, Callable[..., Spec]]
    @classmethod
    def register(cls, name: str, builder: Callable[..., Spec]): ...
    @classmethod
    def build(cls, name: str, **kwargs) -> Spec: ...
    @classmethod
    def compose(cls, *specs: Spec) -> Spec: ...

def profile_spec(func: Callable) -> Callable: ...