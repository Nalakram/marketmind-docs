import abc
from abc import ABC, abstractmethod
from srcPy.preprocessor.graph.ops import Op, OpKind
from typing import Any, Callable

__all__ = ['Graph', 'Node', 'SimpleNode', 'FusedNode', 'register_node_factory', 'serialize', 'deserialize']

class Node(ABC, metaclass=abc.ABCMeta):
    """node class."""
    op: Op = ...
    inputs: list[Node] = ...
    outputs: list[Node] = ...
    def __init__(self, op: Op) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: Any) -> bool: ...
    @abstractmethod
    def to_ir(self) -> dict[str, Any]: ...

class SimpleNode(Node):
    """simple node class."""
    def to_ir(self) -> dict[str, Any]: ...

class FusedNode(Node):
    """fused node class."""
    sub_ops: list[Op] = ...
    def __init__(self, sub_ops: list[Op], fused_kind: OpKind) -> None: ...
    def to_ir(self) -> dict[str, Any]: ...

def register_node_factory(key: str, factory: Callable[[Op], Node]) -> None: ...

class Graph:
    """graph class."""
    nodes: list[Node] = ...
    col_providers: dict[str, list[Node]] = ...
    input_requires: set[str] = ...
    def __init__(self) -> None: ...
    def add_op(self, op: Op) -> Node: ...
    def merge(self, other: Graph) -> None: ...
    def optimize(self) -> None: ...
    def topological_sort(self) -> list[Node]: ...
    def has_cycle(self) -> bool: ...
    def shortest_path(self, start: Node, end: Node) -> list[Node]: ...
    def connected_components(self) -> list[set[Node]]: ...

def serialize(graph: Graph) -> dict[str, Any]: ...
def deserialize(data: dict[str, Any]) -> Graph: ...