from typing import Any as Incomplete
from contextlib import contextmanager
from dataclasses import dataclass
from enum import Enum
from opentelemetry import context
from opentelemetry.sdk.trace.sampling import Sampler
from opentelemetry.trace import Link, Span
from srcPy.utils.capability_manager import HAS as HAS
from srcPy.utils.dependency_manager import deps as deps
from typing import Any, Callable, Iterable, TypeVar

class GrpcError(Exception): ...
class ObservabilityError(Exception): ...
class ExporterEgressError(ObservabilityError): ...
class ExporterTransientError(ObservabilityError): ...
class MetricsEmitError(ObservabilityError): ...
class PiiRedactionError(ObservabilityError): ...
class TracingInitError(ObservabilityError): ...

class _DummySpanKind(Enum):
    """dummy span kind class."""
    INTERNAL = 'INTERNAL'
    SERVER = 'SERVER'
    CLIENT = 'CLIENT'
    PRODUCER = 'PRODUCER'
    CONSUMER = 'CONSUMER'

class _DummyStatusCode:
    """dummy status code class."""
    UNSET: int = ...
    OK: int = ...
    ERROR: int = ...

class _DummyStatus:
    """dummy status class."""
    status_code: Incomplete = ...
    description: Incomplete = ...
    def __init__(self, status_code: int | None = None, description: str | None = None) -> None: ...

class _DummySpanContext:
    """dummy span context class."""
    trace_id: int = ...
    span_id: int = ...
    def __init__(self) -> None: ...

class _DummySpan:
    """dummy span class."""
    attributes: Incomplete = ...
    def __init__(self) -> None: ...
    def get_span_context(self) -> _DummySpanContext: ...
    def set_status(self, *_args, **_kw) -> None: ...
    def record_exception(self, *_args, **_kw) -> None: ...
    def set_attribute(self, *_args, **_kw) -> None: ...

class _DummyLink:
    """dummy link class."""
    def __init__(self, *args, **kwargs) -> None: ...

class _DummyContext: ...

class _DummySampler:
    """dummy sampler class."""
    def should_sample(self, *_a, **_k): ...
    def get_description(self) -> str: ...

class _DummyTraceModule:
    """dummy trace module class."""
    SpanProcessor = object
    def __init__(self) -> None: ...
    def set_tracer_provider(self, *_a, **_k) -> None: ...
    def get_tracer(self, *_a, **_k): ...
    def get_current_span(self): ...
    @contextmanager
    def use_span(self, _span, end_on_exit: bool = True): ...

class _DummyTracer:
    """dummy tracer class."""
    def start_span(self, *_a, **_k) -> _DummySpan: ...

class _DummyMetricsModule:
    """dummy metrics module class."""
    class Observation:
        """observation class."""
        value: Incomplete = ...
        attributes: Incomplete = ...
        def __init__(self, value: float, attributes: dict[str, str] | None = None) -> None: ...
    def __init__(self) -> None: ...
    def set_meter_provider(self, *_a, **_k) -> None: ...
    def get_meter(self, *_a, **_k): ...

class _DummyMeter:
    """dummy meter class."""
    def __init__(self, *args, **kwargs) -> None: ...
    def create_counter(self, *_a, **_k): ...
    def create_histogram(self, *_a, **_k): ...
    def create_observable_gauge(self, *_a, **_k) -> None: ...

class _DummyPrometheusMetricReader:
    """dummy prometheus metric reader class."""
    def __init__(self, *args, **kwargs) -> None: ...

class _DummyPeriodicExportingMetricReader:
    """dummy periodic exporting metric reader class."""
    def __init__(self, *args, **kwargs) -> None: ...

class _DummyAggregationTemporality:
    """dummy aggregation temporality class."""
    DELTA: int = ...
    CUMULATIVE: int = ...

class _DummyView:
    """dummy view class."""
    def __init__(self, *args, **kwargs) -> None: ...

class _DummyResource:
    """dummy resource class."""
    @classmethod
    def create(cls, *args, **kwargs): ...

class _DummyTracerProvider:
    """dummy tracer provider class."""
    def __init__(self, *args, **kwargs) -> None: ...
    def add_span_processor(self, *_a, **_k) -> None: ...

class _DummyBatchSpanProcessor:
    """Processes dummy batch span data."""
    def __init__(self, *args, **kwargs) -> None: ...

class _DummyConsoleSpanExporter:
    """dummy console span exporter class."""
    def __init__(self, *args, **kwargs) -> None: ...

class _DummyParentBased(_DummySampler):
    """dummy parent based class."""
    def __init__(self, *_a, **_k) -> None: ...

class _DummyTraceIdRatioBased(_DummySampler):
    """dummy trace id ratio based class."""
    def __init__(self, *_a, **_k) -> None: ...
OTLPMetricExporter = object
OTLPSpanExporter = object
SamplingResult = object

class TraceContextTextMapPropagator:
    """trace context text map propagator class."""
    def inject(self, _) -> None: ...
    def extract(self, _) -> None: ...

TraceBasedExemplarFilter: Incomplete = ...
ExponentialBucketHistogramAggregation: Incomplete = ...
ExplicitBucketHistogramAggregation: Incomplete = ...

class _NoOpCounter:
    """no op counter class."""
    def add(self, *_args, **_kw) -> None: ...

class _NoOpHistogram:
    """no op histogram class."""
    def record(self, *_args, **_kw) -> None: ...

class _NoOpMeter:
    """no op meter class."""
    def create_counter(self, *_a, **_k): ...
    def create_histogram(self, *_a, **_k): ...
    def create_observable_gauge(self, *_a, **_k) -> None: ...

class NoOpMetricsManager:
    """Manages no op metrics resources and operations."""
    meter: Incomplete = ...
    def __init__(self, *_a, **_k) -> None: ...
    def counter(self, *_a, **_k): ...
    def histogram(self, *_a, **_k): ...
    def record_counter(self, *_a, **_k) -> None: ...
    def record_histogram(self, *_a, **_k) -> None: ...
    def shutdown(self) -> None: ...

class NoOpTracingManager:
    """Manages no op tracing resources and operations."""
    def __init__(self, *_a, **_k) -> None: ...
    def set_sample_rate(self, *_a, **_k) -> None: ...
    def start_span(self, *_a, **_k) -> None: ...
    def start_span_with_links(self, *_a, **_k) -> None: ...
    def inject_context(self, carrier: dict[str, str]): ...
    def extract_context(self, carrier: dict[str, str]): ...
T = TypeVar('T')
F = TypeVar('F', bound=Callable[..., Any])

def set_tenant(tenant_id: str) -> None: ...
def get_tenant() -> str: ...
def set_strategy(strategy_id: str) -> None: ...
def get_strategy() -> str: ...

class CircuitBreaker:
    """circuit breaker class."""
    fail_threshold: Incomplete = ...
    reset_after_sec: Incomplete = ...
    fail_count: int = ...
    opened_at: float | None = ...
    def __init__(self, fail_threshold: int = 5, reset_after_sec: int = 30) -> None: ...
    def on_success(self) -> None: ...
    def on_failure(self) -> None: ...
    def is_open(self) -> bool: ...

class CardinalityLimiter:
    """cardinality limiter class."""
    max_keys: Incomplete = ...
    def __init__(self, max_keys_per_label: int = 1000) -> None: ...
    def sanitize(self, label_key: str, label_value: str) -> str: ...
    def overflow_count(self) -> int: ...
    def stats(self) -> dict[str, Any]: ...

class PIIRedactor:
    """pii redactor class."""
    DEFAULT_PATTERNS: Incomplete = ...
    patterns: Incomplete = ...
    def __init__(self, patterns: dict[str, str] | None = None, fast_keys_allowlist: Iterable[str] | None = None) -> None: ...
    def redact_text(self, text: str) -> str: ...
    def redact_dict(self, data: dict[str, Any]) -> dict[str, Any]: ...

class _Event:
    """event class."""
    kind: Incomplete = ...
    instrument: Incomplete = ...
    value: Incomplete = ...
    labels: Incomplete = ...
    def __init__(self, kind: str, instrument: Any, value: float, labels: dict[str, str]) -> None: ...

class BoundedEventQueue:
    """bounded event queue class."""
    def __init__(self, maxsize: int = 65536) -> None: ...
    def put_nowait(self, ev: _Event) -> bool: ...
    def get_batch(self, n: int = 2048) -> list[_Event]: ...
    def dropped(self) -> int: ...
    def size(self) -> int: ...

@dataclass
class MetricConfig:
    """Configuration for metric."""
    prometheus_port: int = ...
    otlp_endpoint: str | None = ...
    export_interval_millis: int = ...
    delta_temporality: bool = ...
    enable_exemplars: bool = ...
    buffered_emit: bool = ...
    queue_max_events: int = ...
    flush_every_ms: int = ...
    labels_max_keys_per_label: int = ...
    endpoint_allowlist: tuple[str, ...] = ...
    exporter_timeout_sec: float = ...
    breaker_fail_threshold: int = ...
    breaker_reset_seconds: int = ...

class SafeOTLPMetricExporter:
    """safe otlp metric exporter class."""
    def __init__(self, allowlist: tuple[str, ...], breaker: CircuitBreaker, timeout: float, *args, **kwargs) -> None: ...
    def export(self, metrics_data) -> None: ...

class MetricsManager:
    """Manages metrics resources and operations."""
    service_name: Incomplete = ...
    config: Incomplete = ...
    card: Incomplete = ...
    redactor: Incomplete = ...
    provider: Incomplete = ...
    meter: Incomplete = ...
    def __init__(self, service_name: str = 'financial-ml', config: MetricConfig | None = None) -> None: ...
    def counter(self, name: str, description: str = '', unit: str = '1'): ...
    def histogram(self, name: str, description: str = '', unit: str = 'ms'): ...
    def record_counter(self, counter, value: float = 1, labels: dict[str, str] | None = None): ...
    def record_histogram(self, histogram, value: float, labels: dict[str, str] | None = None): ...
    def shutdown(self) -> None: ...

@dataclass
class TracingConfig:
    """Configuration for tracing."""
    otlp_endpoint: str | None = ...
    sample_rate: float = ...
    max_queue_size: int = ...
    max_export_batch_size: int = ...
    schedule_delay_millis: int = ...
    enable_console_export: bool = ...
    endpoint_allowlist: tuple[str, ...] = ...
    exporter_timeout_sec: float = ...

class SafeOTLPSpanExporter:
    """safe otlp span exporter class."""
    def __init__(self, allowlist: tuple[str, ...], breaker: CircuitBreaker, timeout: float, *args, **kwargs) -> None: ...
    def export(self, spans) -> None: ...

class AdaptiveRatioSampler(Sampler):
    """adaptive ratio sampler class."""
    def __init__(self, initial_rate: float) -> None: ...
    def should_sample(self, parent_context, trace_id, name, kind, attributes, links): ...
    def get_description(self) -> str: ...
    def set_rate(self, new_rate: float) -> None: ...

class PiiRedactionSpanProcessor(_SpanProcessorBase):
    """Processes pii redaction span data."""
    redactor: Incomplete = ...
    def __init__(self) -> None: ...
    def on_start(self, span: Span, parent_context: context.Context | None = None) -> None: ...
    def on_end(self, span: Span) -> None: ...
    def shutdown(self) -> None: ...
    def force_flush(self, timeout_millis: int = 30000) -> bool: ...

class TracingManager:
    """Manages tracing resources and operations."""
    service_name: Incomplete = ...
    config: Incomplete = ...
    provider: Incomplete = ...
    tracer: Incomplete = ...
    def __init__(self, service_name: str = 'financial-ml', config: TracingConfig | None = None) -> None: ...
    def set_sample_rate(self, rate: float) -> None: ...
    def start_span(self, name: str, kind: Any = ..., attributes: dict[str, Any] | None = None, links: list[Link] | None = None) -> Span: ...
    def start_span_with_links(self, name: str, linked_spans: Iterable[Span], **kwargs) -> Span: ...
    def inject_context(self, carrier: dict[str, str]) -> dict[str, str]: ...
    def extract_context(self, carrier: dict[str, str]): ...

class TraceEnrichedLogger:
    """trace enriched logger class."""
    def __init__(self, base_logger, service_name: str) -> None: ...
    def info(self, msg: str, **kwargs): ...
    def error(self, msg: str, **kwargs): ...
    def warning(self, msg: str, **kwargs): ...
    def debug(self, msg: str, **kwargs): ...

class LoggingManager:
    """Manages logging resources and operations."""
    service_name: Incomplete = ...
    def __init__(self, service_name: str = 'financial-ml', mm_config: dict[str, Any] | None = None) -> None: ...
    def get_logger(self): ...

class AdaptiveThreshold:
    """adaptive threshold class."""
    alpha: Incomplete = ...
    sensitivity: Incomplete = ...
    def __init__(self, alpha: float = 0.1, sensitivity: float = 3.0, window_size: int = 1024) -> None: ...
    def update(self, value: float) -> bool: ...
    def threshold(self) -> float: ...

class SLOBurnRate:
    """slo burn rate class."""
    windows: Incomplete = ...
    def __init__(self, minutes: Iterable[int] = (1, 5, 30)) -> None: ...
    def record(self, ok: bool) -> None: ...
    def burn_rates(self, slo_error_budget: float) -> dict[int, float]: ...

def instrument(name: str | None = None, labels: dict[str, str] | None = None, record_exceptions: bool = True, measure_latency: bool = True) -> Callable[[F], F]: ...

class FastAPIMiddleware:
    """fast api middleware class."""
    app: Incomplete = ...
    service_name: Incomplete = ...
    def __init__(self, app, service_name: str = 'api', slo_error_budget: float = 0.01) -> None: ...
    async def __call__(self, scope, receive, send): ...

class KafkaInstrumentor:
    """kafka instrumentor class."""
    propagator: Incomplete = ...
    def __init__(self) -> None: ...
    def inject_context(self, headers: dict[str, bytes]) -> dict[str, bytes]: ...
    def extract_context(self, headers: dict[str, bytes]): ...
    def instrument_producer(self, producer): ...
    def instrument_consumer(self, consumer): ...

def register_cache_hit_rate_gauges(cache_client: Any, metric_name: str = 'cache_hit_rate') -> None: ...
def register_cache_hit_rate_gauges_for(func_or_client: Any, metric_name: str = 'cache_hit_rate') -> None: ...
def get_metrics() -> MetricsManager | None: ...
def get_tracing() -> TracingManager | None: ...
def get_logging() -> LoggingManager | None: ...
def get_logger(): ...
def init_observability(service_name: str = 'financial-ml', metrics_config: MetricConfig | None = None, tracing_config: TracingConfig | None = None, enable_metrics: bool = True, enable_tracing: bool = True, enable_logging: bool = True): ...