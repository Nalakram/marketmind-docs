from _typeshed import Incomplete
from contextlib import contextmanager
from dataclasses import dataclass
from enum import Enum
from opentelemetry import context
from opentelemetry.sdk.trace.sampling import Sampler
from opentelemetry.trace import Link, Span
from typing import Any, Callable, Iterable, TypeVar

class GrpcError(Exception): ...
class ObservabilityError(Exception): ...
class ExporterEgressError(ObservabilityError): ...
class ExporterTransientError(ObservabilityError): ...
class MetricsEmitError(ObservabilityError): ...
class PiiRedactionError(ObservabilityError): ...
class TracingInitError(ObservabilityError): ...

class _DummySpanKind(Enum):
    INTERNAL = 'INTERNAL'
    SERVER = 'SERVER'
    CLIENT = 'CLIENT'
    PRODUCER = 'PRODUCER'
    CONSUMER = 'CONSUMER'

class _DummyStatusCode:
    UNSET: int
    OK: int
    ERROR: int

class _DummyStatus:
    status_code: Incomplete
    description: Incomplete
    def __init__(self, status_code: int | None = None, description: str | None = None) -> None: ...

class _DummySpanContext:
    trace_id: int
    span_id: int
    def __init__(self) -> None: ...

class _DummySpan:
    attributes: Incomplete
    def __init__(self) -> None: ...
    def get_span_context(self) -> _DummySpanContext: ...
    def set_status(self, *_args, **_kw) -> None: ...
    def record_exception(self, *_args, **_kw) -> None: ...
    def set_attribute(self, *_args, **_kw) -> None: ...

class _DummyLink:
    def __init__(self, *args, **kwargs) -> None: ...

class _DummyContext: ...

class _DummySampler:
    def should_sample(self, *_a, **_k): ...
    def get_description(self) -> str: ...

class _DummyTraceModule:
    SpanProcessor = object
    def __init__(self) -> None: ...
    def set_tracer_provider(self, *_a, **_k) -> None: ...
    def get_tracer(self, *_a, **_k): ...
    def get_current_span(self): ...
    @contextmanager
    def use_span(self, _span, end_on_exit: bool = True): ...

class _DummyTracer:
    def start_span(self, *_a, **_k) -> _DummySpan: ...

class _DummyMetricsModule:
    class Observation:
        value: Incomplete
        attributes: Incomplete
        def __init__(self, value: float, attributes: dict[str, str] | None = None) -> None: ...
    def __init__(self) -> None: ...
    def set_meter_provider(self, *_a, **_k) -> None: ...
    def get_meter(self, *_a, **_k): ...

class _DummyMeter:
    def __init__(self, *args, **kwargs) -> None: ...
    def create_counter(self, *_a, **_k): ...
    def create_histogram(self, *_a, **_k): ...
    def create_observable_gauge(self, *_a, **_k) -> None: ...

class _DummyPrometheusMetricReader:
    def __init__(self, *args, **kwargs) -> None: ...

class _DummyPeriodicExportingMetricReader:
    def __init__(self, *args, **kwargs) -> None: ...

class _DummyAggregationTemporality:
    DELTA: int
    CUMULATIVE: int

class _DummyView:
    def __init__(self, *args, **kwargs) -> None: ...

class _DummyResource:
    @classmethod
    def create(cls, *args, **kwargs): ...

class _DummyTracerProvider:
    def __init__(self, *args, **kwargs) -> None: ...
    def add_span_processor(self, *_a, **_k) -> None: ...

class _DummyBatchSpanProcessor:
    def __init__(self, *args, **kwargs) -> None: ...

class _DummyConsoleSpanExporter:
    def __init__(self, *args, **kwargs) -> None: ...

class _DummyParentBased(_DummySampler):
    def __init__(self, *_a, **_k) -> None: ...

class _DummyTraceIdRatioBased(_DummySampler):
    def __init__(self, *_a, **_k) -> None: ...
OTLPMetricExporter = object
OTLPSpanExporter = object
SamplingResult = object

class TraceContextTextMapPropagator:
    def inject(self, _) -> None: ...
    def extract(self, _) -> None: ...

TraceBasedExemplarFilter: Incomplete
ExponentialBucketHistogramAggregation: Incomplete
ExplicitBucketHistogramAggregation: Incomplete

class _NoOpCounter:
    def add(self, *_args, **_kw) -> None: ...

class _NoOpHistogram:
    def record(self, *_args, **_kw) -> None: ...

class _NoOpMeter:
    def create_counter(self, *_a, **_k): ...
    def create_histogram(self, *_a, **_k): ...
    def create_observable_gauge(self, *_a, **_k) -> None: ...

class NoOpMetricsManager:
    meter: Incomplete
    def __init__(self, *_a, **_k) -> None: ...
    def counter(self, *_a, **_k): ...
    def histogram(self, *_a, **_k): ...
    def record_counter(self, *_a, **_k) -> None: ...
    def record_histogram(self, *_a, **_k) -> None: ...
    def shutdown(self) -> None: ...

class NoOpTracingManager:
    def __init__(self, *_a, **_k) -> None: ...
    def set_sample_rate(self, *_a, **_k) -> None: ...
    def start_span(self, *_a, **_k) -> None: ...
    def start_span_with_links(self, *_a, **_k) -> None: ...
    def inject_context(self, carrier: dict[str, str]): ...
    def extract_context(self, carrier: dict[str, str]): ...
T = TypeVar('T')
F = TypeVar('F', bound=Callable[..., Any])

def set_tenant(tenant_id: str) -> None: ...
def get_tenant() -> str: ...
def set_strategy(strategy_id: str) -> None: ...
def get_strategy() -> str: ...

class CircuitBreaker:
    fail_threshold: Incomplete
    reset_after_sec: Incomplete
    fail_count: int
    opened_at: float | None
    def __init__(self, fail_threshold: int = 5, reset_after_sec: int = 30) -> None: ...
    def on_success(self) -> None: ...
    def on_failure(self) -> None: ...
    def is_open(self) -> bool: ...

class CardinalityLimiter:
    max_keys: Incomplete
    def __init__(self, max_keys_per_label: int = 1000) -> None: ...
    def sanitize(self, label_key: str, label_value: str) -> str: ...
    def overflow_count(self) -> int: ...
    def stats(self) -> dict[str, Any]: ...

class PIIRedactor:
    DEFAULT_PATTERNS: Incomplete
    patterns: Incomplete
    def __init__(self, patterns: dict[str, str] | None = None, fast_keys_allowlist: Iterable[str] | None = None) -> None: ...
    def redact_text(self, text: str) -> str: ...
    def redact_dict(self, data: dict[str, Any]) -> dict[str, Any]: ...

class _Event:
    kind: Incomplete
    instrument: Incomplete
    value: Incomplete
    labels: Incomplete
    def __init__(self, kind: str, instrument: Any, value: float, labels: dict[str, str]) -> None: ...

class BoundedEventQueue:
    def __init__(self, maxsize: int = 65536) -> None: ...
    def put_nowait(self, ev: _Event) -> bool: ...
    def get_batch(self, n: int = 2048) -> list[_Event]: ...
    def dropped(self) -> int: ...
    def size(self) -> int: ...

@dataclass
class MetricConfig:
    prometheus_port: int = ...
    otlp_endpoint: str | None = ...
    export_interval_millis: int = ...
    delta_temporality: bool = ...
    enable_exemplars: bool = ...
    buffered_emit: bool = ...
    queue_max_events: int = ...
    flush_every_ms: int = ...
    labels_max_keys_per_label: int = ...
    endpoint_allowlist: tuple[str, ...] = ...
    exporter_timeout_sec: float = ...
    breaker_fail_threshold: int = ...
    breaker_reset_seconds: int = ...

class SafeOTLPMetricExporter:
    def __init__(self, allowlist: tuple[str, ...], breaker: CircuitBreaker, timeout: float, *args, **kwargs) -> None: ...
    def export(self, metrics_data) -> None: ...

class MetricsManager:
    service_name: Incomplete
    config: Incomplete
    card: Incomplete
    redactor: Incomplete
    provider: Incomplete
    meter: Incomplete
    def __init__(self, service_name: str = 'financial-ml', config: MetricConfig | None = None) -> None: ...
    def counter(self, name: str, description: str = '', unit: str = '1'): ...
    def histogram(self, name: str, description: str = '', unit: str = 'ms'): ...
    def record_counter(self, counter, value: float = 1, labels: dict[str, str] | None = None): ...
    def record_histogram(self, histogram, value: float, labels: dict[str, str] | None = None): ...
    def shutdown(self) -> None: ...

@dataclass
class TracingConfig:
    otlp_endpoint: str | None = ...
    sample_rate: float = ...
    max_queue_size: int = ...
    max_export_batch_size: int = ...
    schedule_delay_millis: int = ...
    enable_console_export: bool = ...
    endpoint_allowlist: tuple[str, ...] = ...
    exporter_timeout_sec: float = ...

class SafeOTLPSpanExporter:
    def __init__(self, allowlist: tuple[str, ...], breaker: CircuitBreaker, timeout: float, *args, **kwargs) -> None: ...
    def export(self, spans) -> None: ...

class AdaptiveRatioSampler(Sampler):
    def __init__(self, initial_rate: float) -> None: ...
    def should_sample(self, parent_context, trace_id, name, kind, attributes, links): ...
    def get_description(self) -> str: ...
    def set_rate(self, new_rate: float) -> None: ...

class PiiRedactionSpanProcessor(_SpanProcessorBase):
    redactor: Incomplete
    def __init__(self) -> None: ...
    def on_start(self, span: Span, parent_context: context.Context | None = None) -> None: ...
    def on_end(self, span: Span) -> None: ...
    def shutdown(self) -> None: ...
    def force_flush(self, timeout_millis: int = 30000) -> bool: ...

class TracingManager:
    service_name: Incomplete
    config: Incomplete
    provider: Incomplete
    tracer: Incomplete
    def __init__(self, service_name: str = 'financial-ml', config: TracingConfig | None = None) -> None: ...
    def set_sample_rate(self, rate: float) -> None: ...
    def start_span(self, name: str, kind: Any = ..., attributes: dict[str, Any] | None = None, links: list[Link] | None = None) -> Span: ...
    def start_span_with_links(self, name: str, linked_spans: Iterable[Span], **kwargs) -> Span: ...
    def inject_context(self, carrier: dict[str, str]) -> dict[str, str]: ...
    def extract_context(self, carrier: dict[str, str]): ...

class TraceEnrichedLogger:
    def __init__(self, base_logger, service_name: str) -> None: ...
    def info(self, msg: str, **kwargs): ...
    def error(self, msg: str, **kwargs): ...
    def warning(self, msg: str, **kwargs): ...
    def debug(self, msg: str, **kwargs): ...

class LoggingManager:
    service_name: Incomplete
    def __init__(self, service_name: str = 'financial-ml', mm_config: dict[str, Any] | None = None) -> None: ...
    def get_logger(self): ...

class AdaptiveThreshold:
    alpha: Incomplete
    sensitivity: Incomplete
    def __init__(self, alpha: float = 0.1, sensitivity: float = 3.0, window_size: int = 1024) -> None: ...
    def update(self, value: float) -> bool: ...
    def threshold(self) -> float: ...

class SLOBurnRate:
    windows: Incomplete
    def __init__(self, minutes: Iterable[int] = (1, 5, 30)) -> None: ...
    def record(self, ok: bool) -> None: ...
    def burn_rates(self, slo_error_budget: float) -> dict[int, float]: ...

def instrument(name: str | None = None, labels: dict[str, str] | None = None, record_exceptions: bool = True, measure_latency: bool = True) -> Callable[[F], F]: ...

class FastAPIMiddleware:
    app: Incomplete
    service_name: Incomplete
    def __init__(self, app, service_name: str = 'api', slo_error_budget: float = 0.01) -> None: ...
    async def __call__(self, scope, receive, send): ...

class KafkaInstrumentor:
    propagator: Incomplete
    def __init__(self) -> None: ...
    def inject_context(self, headers: dict[str, bytes]) -> dict[str, bytes]: ...
    def extract_context(self, headers: dict[str, bytes]): ...
    def instrument_producer(self, producer): ...
    def instrument_consumer(self, consumer): ...

def register_cache_hit_rate_gauges(cache_client: Any, metric_name: str = 'cache_hit_rate') -> None: ...
def register_cache_hit_rate_gauges_for(func_or_client: Any, metric_name: str = 'cache_hit_rate') -> None: ...
def get_metrics() -> MetricsManager | None: ...
def get_tracing() -> TracingManager | None: ...
def get_logging() -> LoggingManager | None: ...
def get_logger(): ...
def init_observability(service_name: str = 'financial-ml', metrics_config: MetricConfig | None = None, tracing_config: TracingConfig | None = None, enable_metrics: bool = True, enable_tracing: bool = True, enable_logging: bool = True): ...
