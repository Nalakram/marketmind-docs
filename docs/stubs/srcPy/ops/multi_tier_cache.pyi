import asyncio
from _typeshed import Incomplete
from concurrent.futures import Future
from dataclasses import dataclass
from typing import Any, Callable, TypeVar

PYARROW_AVAILABLE: bool
redis: Incomplete
REDIS_AVAILABLE: Incomplete
T = TypeVar('T')

def version_to_int(version_str: str) -> int: ...

@dataclass
class Call:
    future: Future | asyncio.Future
    start_time: float
    is_async: bool = ...

class Singleflight:
    def __init__(self) -> None: ...
    def do(self, key: Any, fn: Callable[[], T]) -> tuple[T, bool]: ...
    async def do_async(self, key: Any, fn: Callable) -> tuple[T, bool]: ...

class L2Cache:
    def get(self, key: str) -> Any | None: ...
    def set(self, key: str, value: Any, ttl: float | None = None): ...
    def invalidate(self, key: str): ...

class PlasmaL2Cache(L2Cache):
    client: Incomplete
    def __init__(self, plasma_path: str = '/tmp/plasma') -> None: ...
    def get(self, key: str) -> Any | None: ...
    def set(self, key: str, value: Any, ttl: float | None = None): ...
    def invalidate(self, key: str): ...

class MemfdL2Cache(L2Cache):
    cache_dir: Incomplete
    def __init__(self, cache_dir: str = '/dev/shm/l2_cache') -> None: ...
    def get(self, key: str) -> Any | None: ...
    def set(self, key: str, value: Any, ttl: float | None = 60) -> None: ...
    def invalidate(self, key: str): ...

class L3Cache:
    redis: Incomplete
    key_prefix: Incomplete
    def __init__(self, redis_client=None, key_prefix: str = 'l3:') -> None: ...
    def get(self, key: str) -> Any | None: ...
    def set(self, key: str, value: Any, ttl: float | None = None): ...
    def invalidate(self, key: str): ...
    def publish_invalidation(self, channel: str, key: str): ...

@dataclass
class TierMetrics:
    tier_name: str
    hits: int = ...
    misses: int = ...
    sets: int = ...
    promotions: int = ...
    latency_ns: int = ...
    @property
    def hit_rate(self) -> float: ...
    @property
    def avg_latency_us(self) -> float: ...

class MultiTierMetrics:
    l1: Incomplete
    l2: Incomplete
    l3: Incomplete
    l4: Incomplete
    singleflight_saved: int
    def __init__(self) -> None: ...
    def summary(self) -> dict[str, Any]: ...

class InvalidationListener:
    redis: Incomplete
    channel: Incomplete
    callback: Incomplete
    def __init__(self, redis_client, channel: str, callback: Callable[[str], None]) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

class MultiTierClient:
    l1: Incomplete
    l2: Incomplete
    l3: Incomplete
    l4: Incomplete
    singleflight: Incomplete
    ttl_jitter: Incomplete
    check_l4_on_miss: Incomplete
    metrics: Incomplete
    def __init__(self, l1_size: int = 128, l1_ttl: float | None = 60, l2_type: str = 'memfd', l2_path: str | None = None, redis_client=None, l3_key_prefix: str = 'l3:', l4_cache_dir: str = '.cache', enable_singleflight: bool = True, ttl_jitter: float = 0.1, check_l4_on_miss: bool = False, enable_invalidation_listener: bool = True) -> None: ...
    def get(self, key: str, version: int = 0) -> Any | None: ...
    def set(self, key: str, value: Any, ttl: float | None = None, version: int = 0, write_through: bool = True, persist_to_l4: bool = False): ...
    def compute_or_get(self, key: str, compute_fn: Callable[[], T], ttl: float | None = None, version: int = 0, persist_to_l4: bool = False) -> T: ...
    async def compute_or_get_async(self, key: str, compute_fn: Callable, ttl: float | None = None, version: int = 0, persist_to_l4: bool = False) -> T: ...
    def invalidate(self, key: str, broadcast: bool = True): ...
    def invalidate_pattern(self, prefix: str, broadcast: bool = True): ...
    def close(self) -> None: ...

def multi_tier_cache(ttl: float | None = 60, version: str = 'v1', persist_large_objects: bool = False, key_fn: Callable[[Callable[..., Any], tuple[Any, ...], dict[str, Any]], str] | None = None, redis_client=None, l2_type: str = 'memfd', check_l4_on_miss: bool = False): ...

class PrometheusExporter:
    client: Incomplete
    def __init__(self, client: MultiTierClient) -> None: ...
    def export(self) -> str: ...
