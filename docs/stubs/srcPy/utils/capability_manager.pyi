from collections.abc import Generator
from contextlib import contextmanager
from dataclasses import dataclass
from typing import Any, Final, Literal

__all__ = ['deps', 'HAS', 'CAPABILITIES', 'resolve_capability', 'CapabilityOption']

deps: CapabilityManager | None
HAS: _LazyHAS | None

class _NoopMetric:
    def __init__(self, *a, **k) -> None: ...
    def labels(self, *a, **k): ...
    def inc(self, *a, **k) -> None: ...
    def observe(self, *a, **k) -> None: ...
    @contextmanager
    def time(self) -> Generator[None]: ...

@dataclass
class _BackendStats:
    calls: int = ...
    errors: int = ...
    ewma_latency_ms: float = ...

@dataclass
class _BackendHealth:
    status: Status = ...
    p99_proxy_ms: float = ...
    error_rate: float = ...

class _MonitoredProxy:
    def __init__(self, manager: CapabilityManager, obj: Any, capability_key: str, backend_key: str) -> None: ...
    def __getattr__(self, name: str) -> Any: ...
    def __call__(self, *a, **k): ...

@dataclass(frozen=True)
class _Dependency:
    module_path: str
    pip_name: str
    purpose: str
    obj_name: str | None = ...
    min_version: str | None = ...

class _LazyProxy:
    def __init__(self, key: str, manager: CapabilityManager) -> None: ...
    def __getattr__(self, name: str) -> Any: ...
    def __call__(self, *a, **k): ...

class _LazyHAS:
    def __init__(self, manager: CapabilityManager) -> None: ...
    def __getattr__(self, name: str) -> bool: ...
    def reset(self) -> None: ...

class CapabilityManager:
    def __new__(cls, *a, **k) -> CapabilityManager: ...
    def __init__(self, config: dict[str, _Dependency]) -> None: ...
    def resolve(self, capability: str) -> Any: ...
    def has(self, key: str) -> bool: ...
    def ensure(self, key: str, _raise: bool = True) -> Any: ...
    def register(self, key: str, dep: _Dependency, *, force: bool = False) -> None: ...
    def reload(self, keys: list[str] | None = None) -> None: ...
    def warm_up_in_background(self) -> None: ...
    def __getattr__(self, key: str) -> Any: ...
CapabilityOption = str | tuple[str, str]
CAPABILITIES: Final[dict[str, list[CapabilityOption]]]

def resolve_capability(capability: Literal['dataframe', 'classifier']) -> Any: ...
