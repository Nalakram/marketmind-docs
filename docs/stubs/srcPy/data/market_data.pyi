import polars as pl
from typing import Any as Incomplete
from dataclasses import dataclass
from srcPy.pipeline.stages.market_data.sources.base import DataSource as DataSource
from srcPy.utils.exceptions import DataFetchError as DataFetchError
from typing import Any, AsyncIterator, Awaitable, Callable, Hashable, Iterable, Mapping, TypeVar

T = TypeVar('T')

class AsyncLRU:
    """async lru class."""
    maxsize: Incomplete = ...
    ttl: Incomplete = ...
    def __init__(self, maxsize: int = 512, ttl: float = 300.0) -> None: ...
    async def get_or_set(self, key: Hashable, coro_factory: Callable[[], Awaitable[T]]) -> T: ...

class SourceRegistry:
    """source registry class."""
    def __init__(self) -> None: ...
    def register(self, name: str, cls: type[DataSource]) -> None: ...
    def names(self) -> list[str]: ...
    def get(self, name: str) -> DataSource | None: ...
    def create(self, name: str, cfg: Mapping[str, Any]) -> DataSource: ...
    def ensure(self, name: str, cfg: Mapping[str, Any]) -> DataSource: ...

REGISTRY: Incomplete = ...

def register_source(name: str) -> Callable[[type[DataSource]], type[DataSource]]: ...

class CompositeSource(DataSource):
    """composite source class."""
    def __init__(self, cfg: Mapping[str, Any]) -> None: ...
    async def get_historical(self, symbol: str, start: str, end: str, *, eager: bool = False) -> pl.LazyFrame: ...
    async def get_realtime(self, symbol: str, *, interval: float = 60.0) -> AsyncIterator[pl.DataFrame]: ...

class FailoverSource(DataSource):
    """failover source class."""
    def __init__(self, cfg: Mapping[str, Any]) -> None: ...
    async def get_historical(self, symbol: str, start: str, end: str, *, eager: bool = False) -> pl.LazyFrame: ...
    async def get_realtime(self, symbol: str, *, interval: float = 60.0) -> AsyncIterator[pl.DataFrame]: ...

@dataclass
class MarketDataConfig:
    """Configuration for market data."""
    default_source: str = ...
    cache_maxsize: int = ...
    cache_ttl: float = ...
    retry_attempts: int = ...
    retry_base_delay: float = ...
    fanout_concurrency: int = ...
    source_configs: Mapping[str, Mapping[str, Any]] = ...

class MarketDataManager:
    """Manages market data resources and operations."""
    cfg: Incomplete = ...
    def __init__(self, *, config: MarketDataConfig | None = None) -> None: ...
    def register_instance(self, name: str, src: DataSource) -> None: ...
    async def get_historical(self, symbol: str, start: str, end: str, *, source_name: str | None = None, eager: bool = False) -> pl.LazyFrame: ...
    async def get_historical_cached(self, symbol: str, start: str, end: str, *, source_name: str | None = None, eager: bool = False) -> pl.LazyFrame: ...
    async def get_historical_many(self, symbols: Iterable[str], start: str, end: str, *, source_name: str | None = None, eager: bool = False, use_cache: bool = True) -> pl.LazyFrame: ...
    async def get_historical_auto(self, symbol: str, start: str, end: str, *, candidates: list[str] | None = None, eager: bool = False) -> pl.LazyFrame: ...
    async def get_realtime(self, symbol: str, *, source_name: str | None = None, interval: float = 60.0) -> AsyncIterator[pl.DataFrame]: ...
    def close(self) -> None: ...

def build_client_from_config(cfg: Mapping[str, Any]) -> MarketDataManager: ...

add_moving_average: Incomplete = ...
add_rsi: Incomplete = ...
cached_historical: Incomplete = ...
normalize: Incomplete = ...
validate_dataframe: Incomplete = ...