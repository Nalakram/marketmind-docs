import abc
import polars as pl
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from polars._typing import SchemaDict as SchemaDict
from srcPy.pipeline.stages.cleaning.validators.contracts import MarketDataFrameSchema as MarketDataFrameSchema
from typing import Any, AsyncIterator, Callable, Generic, Protocol, TypeVar

@dataclass
class Order:
    """order class."""
    order_id: int = ...
    action: str = ...
    total_quantity: float = ...
    order_type: str = ...
    lmt_price: float | None = ...
    aux_price: float | None = ...
    tif: str = ...
    account: str | None = ...
    symbol: str | None = ...
    solicited: bool = ...
    extra: dict[str, Any] = field(default_factory=dict)
    @classmethod
    def market(cls, symbol: str, qty: float) -> Order: ...

@dataclass
class Position:
    """position class."""
    account: str = ...
    symbol: str = ...
    position: float = ...
    avg_cost: float = ...
    model_code: str | None = ...
    extra: dict[str, Any] = field(default_factory=dict)

PositionSchema: SchemaDict
HistoricalSchema: SchemaDict

class OrderExecutor(Protocol):
    """order executor class."""
    def submit(self, order: Order) -> str: ...
    def submit_batch(self, orders: list[Order]) -> list[str]: ...
    def cancel(self, order_id: str) -> None: ...
    def status(self, order_id: str) -> str: ...

class PositionService(Protocol):
    """position service implementation."""
    def get_positions(self) -> list[Position]: ...
    def get_positions_as_polars(self) -> pl.DataFrame: ...

class MarketDataProvider(Protocol):
    """market data provider class."""
    def get_price(self, symbol: str) -> float: ...
    def get_prices(self, symbols: list[str]) -> dict[str, float]: ...
    def get_historical(self, symbol: str, start: str, end: str, interval: str = '1min', lazy: bool = True) -> pl.LazyFrame | pl.DataFrame: ...
    def get_historical_batch(self, symbols: list[str], start: str, end: str, interval: str = '1min', lazy: bool = True) -> dict[str, pl.LazyFrame | pl.DataFrame]: ...
    def map_over(self, symbols: list[str], fn: Callable[[str], pl.LazyFrame], combine: Callable[[list[pl.LazyFrame]], pl.LazyFrame] = ...) -> pl.LazyFrame: ...
    async def stream_realtime(self, symbol: str, interval: float = 60.0) -> AsyncIterator[pl.DataFrame]: ...

class AsyncMarketDataProvider(MarketDataProvider, Protocol):
    """async market data provider class."""
    async def get_price_async(self, symbol: str) -> float: ...
    async def get_prices_async(self, symbols: list[str]) -> dict[str, float]: ...

class EconomicDataProvider(Protocol):
    """economic data provider class."""
    def get_indicator(self, indicator: str, start: str, end: str) -> pl.LazyFrame: ...
T_co = TypeVar('T_co', covariant=True)

class ProviderFactory(ABC, Generic[T_co], metaclass=abc.ABCMeta):
    """Factory for creating provider instances."""
    @classmethod
    def register(cls, provider_type: str) -> Callable[[type['ProviderFactory']], type['ProviderFactory']]: ...
    @classmethod
    def load_entry_points(cls, group: str = 'marketmind.providers') -> int: ...
    @classmethod
    def create(cls, provider_type: str, config: dict[str, Any], **kwargs) -> T_co: ...
    @abstractmethod
    def build_provider(self, config: dict[str, Any], **kwargs) -> T_co: ...

class RiskManager:
    """Manages risk resources and operations."""
    def validate(self, order) -> None: ...

class PositionSizer:
    """position sizer class."""
    def size(self, symbol: str, signal: float, price: float) -> float: ...